//servo v. 0.1
#include <SoftwareSerial.h>
#include <Servo.h>
#define RX 3   
#define TX 6
#define S1P 10  //порт управления первым сервоприводом
#define S2P 11  //-||- вторым сервоприводом
#define MXANG 180  //максимальный угол поворота
#define MINANG 0  //минимальный угол поворота
#define STRTANG 90  //стартовый угол

/*Допускается 4 распознаваемых байта, соответствующих '7,'9','1','0';
При первом получении определенного байта он запоминается, дается допуск к повороту и совершается сам поворот.
Если далее мы не получаем новых байтов, то поворот продолжается. Если получаем повтороно тот же байт,
то прекращаем поворот( обнуляется поле запомненного байта и дается запрет на поворот). Если получаем иной, но допустимый байт, то либо меняем направление
поворота(если новый байт ответственен за поворот в одной плоскости с имеющимся; допуск на поворот сохраняется, но меняется поле запомненного байта), 
либо начинаем поворот второго сервопривода, либо никаких действий не предпринимаем(если байт не является допустимым)*/

SoftwareSerial myser(RX,TX);
Servo servo1;  
Servo servo2;

//Вектор поворота сервопривода
struct Vect
{
    char mas[2];  //допустимые клавиши поворота
    int bt;  //принятый байт(код клавиши)
    int ex;  //допуск поворота
    int ang;  //имеющийся угол поворота
}P1,P2;  //вектора для серовприводов 1(влево-вправо) и 2(вверх-вниз)

char incomingbyte;  
int  LED = 13;       

int prov( struct Vect *, char);  //функция проверки допустимости входного байта для сервоприводов

void setup() {
  
  P1.mas[0]='7';
  P1.mas[1]='9';
  P2.mas[0]='1';
  P2.mas[1]='0';
  P1.bt=P1.ex=0;
  P2.bt=P2.ex=0;
  
  myser.begin(9600);
  pinMode(LED, OUTPUT);
  
  servo1.attach(S1P);
  servo2.attach(S2P);
  P1.ang=STRTANG;
  P2.ang=STRTANG;
  servo1.write(P1.ang);
  servo2.write(P2.ang);
}
 
void loop() {
  digitalWrite(LED,0);
/*Если идет прием байтов, то проверяем, входят ли они в диапазон 
назначенных за управление байтов. В зависимости от этого будем либо
изменять направление поворота(или останавливать), либо же никакие 
действия производить не будем*/
  if (myser.available() > 0)
  {  
     incomingbyte = myser.read(); // считываем байт
     if (prov(&P1,incomingbyte));  //проверяем, входит ли в диапазон разрешенных байт первого сервопривода
       else  
         prov(&P2,incomingbyte);  //-||- второго сервопривода
  }
//Если поворот серовприводов разрешен, то оцениваем направление поворота 
  if(P1.ex)
  {
      if(P1.bt==P1.mas[0]&&P1.ang>MINANG)  //если поворот против часовой стрелки и угол больше 0  
          {
            P1.ang-=1;  
            servo1.write(P1.ang);
          }
      else if(P1.bt==P1.mas[1]&&P1.ang<MXANG)  //если по часовой и угол меньше 180
          {
            P1.ang+=1;
            servo1.write(P1.ang);
          }
      else P1.ex=0;  //Иные случаи- запрет на поворот
  }
  if(P2.ex)
  {
      if(P2.bt==P2.mas[0]&&P2.ang>MINANG)
      {
        P2.ang-=1;
        servo2.write(P2.ang);
      }
      else if(P2.bt==P2.mas[1]&&P2.ang<MXANG)
      {
         P2.ang+=1;
        servo2.write(P2.ang);
      }
      else P2.ex=0;
  }
  
  delay(50);
}
    
int prov(struct Vect *p, char c)
{
  if((p->mas[0]==c)||p->mas[1]==c)  //если байт входит в диапозон 
  {
    if(c==p->bt)  //если до этого данный байт был нажат
    {
      //то даем команды к запрету поворота
      p->ex=0;  //запрет поворота
      p->bt=0;  //обнуляем запомненный байт
    }
    else
    {
      //иначе разрешаем поворот и запоминаем байт
      p->ex=1;
      p->bt=c;
    }
    return 1;
  }
  return 0;
}
