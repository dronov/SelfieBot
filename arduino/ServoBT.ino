#include <Servo.h>
#define RX 3  //(analog)   
#define TX 5  //(analog)
#define BTN 8   //порт считывания сигнала кнопки(digit)
#define S1P 10  //порт управления первым сервоприводом(up/down)(analog)
#define S2P 11  //-||- вторым сервоприводом(analog)
#define MXANG 180  //максимальный угол поворота
#define MINANG 0  //минимальный угол поворота
#define STRTANG 90  //стартовый угол

/*Изначально включаем питание для микроконтроллера. Серовоприводы остаются выключенными.
Кнопка нажимется- сервоприводы встают в базовое положение. Вновь нажатие- контроль за ними прерывается/*
/*Допускается 4 распознаваемых байта, соответствующих '7,'9','1','0';
При первом получении определенного байта он запоминается, дается допуск к повороту и совершается сам поворот.
Если далее мы не получаем новых байтов, то поворот продолжается. Если получаем повтороно тот же байт,
то прекращаем поворот( обнуляется поле запомненного байта и дается запрет на поворот). Если получаем иной, но допустимый байт, то либо меняем направление
поворота(если новый байт ответственен за поворот в одной плоскости с имеющимся; допуск на поворот сохраняется, но меняется поле запомненного байта), 
либо начинаем поворот второго сервопривода, либо никаких действий не предпринимаем(если байт не является допустимым)*/

Servo servo1;  
Servo servo2;
//Вектор поворота сервопривода
struct Vect
{
    char mas[2];  //допустимые клавиши поворота
    int bt;  //принятый байт(код клавиши)
    int ex;  //допуск поворота
    int ang;  //имеющийся угол поворота

}P1,P2;  //вектора для серовприводов 1(влево-вправо) и 2(вверх-вниз)

const int buf_length=8;
char buffer[buf_length];
char incomingbyte;  
int onboardLed = 13;      
int delta;
int i;  //флаг приема данных
int prov( struct Vect *, char);  //функция проверки допустимости входного байта для сервоприводов
char inputStr[5]; // ПРИНИМАЕМОЕ СООБЩЕНИЕ



void setup() {
  Serial.begin(9600);
  P1.mas[0]='w';
  P1.mas[1]='s';
  P2.mas[0]='d';
  P2.mas[1]='a';
  P1.bt=P1.ex=0;
  P2.bt=P2.ex=0;
  delta=2;
  pinMode(onboardLed, OUTPUT);
  pinMode(7,OUTPUT);
  digitalWrite(onboardLed, HIGH);
  servo1.attach(S1P);
      servo2.attach(S2P);
      P1.ang=STRTANG;
      P2.ang=STRTANG;
      servo1.write(P1.ang);
      servo2.write(P2.ang);
  i=0;  //0- флаг указывает на то, что данные не были получены. Иначе флаг равен 1.
}
 
void loop() {
    /*Если идет прием байтов, то проверяем, входят ли они в диапазон 
назначенных за управление байтов. В зависимости от этого будем либо
изменять направление поворота(или останавливать), либо же никакие 
действия производить не будем*/
if (Serial.available() > 0)
  {  
    Serial.readBytes(buffer, buf_length); // считываем бай
     if (prov(&P1,buffer[0]));  //проверяем, входит ли в диапазон разрешенных байт первого сервопривода
       else  
         prov(&P2,buffer[0]);  //-||- второго сервопривода
     flushLed(100);
  }
//Если поворот серовприводов разрешен, то оцениваем направление поворота 
  if(P1.ex)
  {
      if(  P1.bt==P1.mas[0]&&P1.ang>MINANG+50)  //если поворот против часовой стрелки и угол больше 0  
          {
            P1.ang-=delta;  
            servo1.write(P1.ang);
          }
      else if(P1.bt==P1.mas[1]&&P1.ang<MXANG-20)  //если по часовой и угол меньше 180
          {
            P1.ang+=delta;
            servo1.write(P1.ang);
          }
      else P1.ex=0;  //Иные случаи- запрет на поворот
  }
  if(P2.ex)
  {
      if(P2.bt==P2.mas[0]&&P2.ang>MINANG+20)
      {
        P2.ang-=delta;
        servo2.write(P2.ang);
      }
      else if(P2.bt==P2.mas[1]&&P2.ang<MXANG-20)
      {
         P2.ang+=delta;
        servo2.write(P2.ang);
      }
      else P2.ex=0;
  
  } 
  delay(25);
  i=0;  
  //если нажимаем кнопку
}
    
int prov(struct Vect *p, char c)
{
  if((p->mas[0]==c)||p->mas[1]==c)  //если байт входит в диапозон 
  {
    if(c==p->bt)  //если до этого данный байт был нажат
    {
      //то даем команды к запрету поворота
      p->ex=0;  //запрет поворота
      p->bt=0;  //обнуляем запомненный байт
    }
    else
    {
      //иначе разрешаем поворот и запоминаем байт
      p->ex=1;
      p->bt=c;
    }
    return 1;
  }
  return 0;
}

void flushLed(int time)
{
  digitalWrite(7, HIGH);
  delay(time);
  digitalWrite(7, LOW);
  delay(time);
}
